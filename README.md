# Multi_ch、


## 流程
1. 入口 ： ``fit.py``
2. 调 ``test.py`` 读入数据，同时调用 ``main``获取初始路线池
3. ``LNS``:
   1. 获取初始解 ``get_init_sol``： 按顺序尝试每一个可插入位置，找到最佳目前最佳插入位置，不能插入时，新建一条路线。
   2. 退火：通过不同的删除和插入操作，不断重构解，如果变好了，就保留，如果变差了，就概率保留。
3. 删除操作：
   1. ``Random_Remove(instance,NonImp,cur_sol)`` 从当前路径池 ``cur_sol`` 中，随机删除 ``NonImp`` 个点
   2. ``Distance_Related_Remove(instasnce,NonUImp,Cur_sol,Dis_List`` 随机挑选一个点，删除掉与这个点距离最近的 ``min(N - 1,NonImp)`` 个点
   3. 
4. 插入操作：
   1. ``Random_Ins(instance,cur_sol,bank)`` 将删除掉的 ``bank`` 中的点，随机的插入到当前解 ``cur_sol`` 中
## DP方案


``DP[i][j][k][0/1]``: 充电车到 ``i`` 点，还剩 ``j`` 的电量，充 ``k`` 的电量

0: 总消耗 pd * distance + pk * charge (系数 * 距离 + 系数 * 充电量)

1：最晚充电的点( ``k > 0``,``dp[i][j][k][1] = i``、``k == 0`` , 前一个转移来的点的 ``1``)

范围 ： ``[node_num][0-100][0-100]``

## 一些个问题设定
1. 充电时间远小于服务时间

## 一些问题

1. 何时检查一段路径相邻两点距离是否超过了满电量能走的距离，初始化路径的时候没有check这个问题，初始化的时候，如果和时间一起check很有可能找不到解陷入死循环，（e.g : 其他路径已经插不下了，当前剩下的点从仓库直接去不了），或者可以考虑造数据的时候，避免这种事情，保证仓库和任意点可达。
2. 充电时间对时间窗合法性的关系 ，挑选充电的点的同时如何保证在这些点充电可以始终满足时间窗（或者直接假设充电时间小于服务时间，但有点不符合实际）
3. 数据类型，距离为小数，电量为整数，直接四舍五入？





